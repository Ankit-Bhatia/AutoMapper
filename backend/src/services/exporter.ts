/**
 * AutoMapper Export Service
 * =========================
 * Generates platform-specific integration artefacts from a completed mapping project.
 *
 * Supported output formats:
 *   json        — Canonical AutoMapper JSON (platform-neutral, versioned)
 *   yaml        — Same as JSON but YAML — easier to diff/review in source control
 *   csv         — Spreadsheet-friendly flat table (for business stakeholders)
 *   dataweave   — MuleSoft Anypoint DataWeave 2.0 transformation script (.dwl)
 *   boomi       — Dell Boomi Data Map XML component descriptor (.xml)
 *   workato     — Workato recipe JSON skeleton (.json)
 *
 * Design principle: ALL formats derive from the same internal BuildInput so the
 * canonical data is a single source of truth and platform adapters are pure functions.
 */
import type {
  Entity,
  EntityMapping,
  Field,
  FieldMapping,
  MappingProject,
  System,
  ValidationReport,
} from '../types.js';

// ─── Shared input shape ────────────────────────────────────────────────────────

export interface BuildInput {
  project: MappingProject;
  systems: System[];
  entityMappings: EntityMapping[];
  fieldMappings: FieldMapping[];
  entities: Entity[];
  fields: Field[];
  validation?: ValidationReport;
}

// ─── Internal helpers ──────────────────────────────────────────────────────────

function entityById(input: BuildInput) {
  return new Map(input.entities.map((e) => [e.id, e]));
}

function fieldById(input: BuildInput) {
  return new Map(input.fields.map((f) => [f.id, f]));
}

function entityMappingById(input: BuildInput) {
  return new Map(input.entityMappings.map((e) => [e.id, e]));
}

function systemName(systemId: string, systems: System[]): string {
  return systems.find((s) => s.id === systemId)?.name ?? systemId;
}

function systemType(systemId: string, systems: System[]): string {
  return systems.find((s) => s.id === systemId)?.type ?? 'generic';
}

/** Group field mappings by their entity mapping id */
function groupFieldMappings(input: BuildInput): Map<string, FieldMapping[]> {
  const map = new Map<string, FieldMapping[]>();
  for (const fm of input.fieldMappings) {
    if (!map.has(fm.entityMappingId)) map.set(fm.entityMappingId, []);
    map.get(fm.entityMappingId)!.push(fm);
  }
  return map;
}

const BANNER = '// Generated by AutoMapper — https://github.com/your-org/AutoMapper';
const TS = () => new Date().toISOString();

// ─── 1. Canonical JSON ────────────────────────────────────────────────────────

/**
 * Platform-neutral canonical JSON export.
 * This is the source-of-truth format that all other adapters are derived from.
 * It can be consumed by custom connectors in any iPaaS platform, stored in source
 * control, or used as an import spec for future AutoMapper projects.
 */
export function buildJsonExport(input: BuildInput): object {
  const entities = entityById(input);
  const fields = fieldById(input);
  const fmByEm = groupFieldMappings(input);

  const srcName = systemName(input.project.sourceSystemId, input.systems);
  const tgtName = systemName(input.project.targetSystemId, input.systems);
  const srcType = systemType(input.project.sourceSystemId, input.systems);
  const tgtType = systemType(input.project.targetSystemId, input.systems);

  return {
    automapper: {
      version: '1.0',
      exportedAt: TS(),
      exportFormat: 'canonical-json',
      project: {
        id: input.project.id,
        name: input.project.name,
        createdAt: input.project.createdAt,
        updatedAt: input.project.updatedAt,
      },
      source: { name: srcName, type: srcType, systemId: input.project.sourceSystemId },
      target: { name: tgtName, type: tgtType, systemId: input.project.targetSystemId },
      entityMappings: input.entityMappings.map((em) => {
        const src = entities.get(em.sourceEntityId);
        const tgt = entities.get(em.targetEntityId);
        const fms = fmByEm.get(em.id) ?? [];
        return {
          id: em.id,
          confidence: em.confidence,
          rationale: em.rationale,
          sourceEntity: { name: src?.name ?? em.sourceEntityId, label: src?.label, description: src?.description },
          targetEntity: { name: tgt?.name ?? em.targetEntityId, label: tgt?.label },
          fieldMappings: fms.map((fm) => {
            const sf = fields.get(fm.sourceFieldId);
            const tf = fields.get(fm.targetFieldId);
            return {
              id: fm.id,
              confidence: fm.confidence,
              status: fm.status,
              rationale: fm.rationale,
              source: {
                fieldName: sf?.name ?? fm.sourceFieldId,
                label: sf?.label,
                dataType: sf?.dataType,
                required: sf?.required,
                isKey: sf?.isKey,
                length: sf?.length,
                precision: sf?.precision,
                picklistValues: sf?.picklistValues,
              },
              target: {
                fieldName: tf?.name ?? fm.targetFieldId,
                label: tf?.label,
                dataType: tf?.dataType,
                required: tf?.required,
                isKey: tf?.isKey,
              },
              transform: fm.transform,
            };
          }),
        };
      }),
      compliance: input.validation ?? null,
      metadata: {
        totalEntityMappings: input.entityMappings.length,
        totalFieldMappings: input.fieldMappings.length,
        acceptedMappings: input.fieldMappings.filter((fm) => fm.status === 'accepted').length,
        highConfidenceMappings: input.fieldMappings.filter((fm) => fm.confidence >= 0.8).length,
        complianceWarnings: input.validation?.warnings.length ?? 0,
      },
    },
  };
}

// ─── 2. YAML ─────────────────────────────────────────────────────────────────

/**
 * Canonical YAML export — same data as JSON but in YAML format.
 * Easier to diff in pull requests and read by tools like Boomi Data Catalog.
 * Does NOT use a yaml library dependency — generates YAML manually to avoid
 * adding a new dependency. Handles the mapping data structure which is well-known.
 */
export function buildYamlExport(input: BuildInput): string {
  const entities = entityById(input);
  const fields = fieldById(input);
  const fmByEm = groupFieldMappings(input);

  const srcName = systemName(input.project.sourceSystemId, input.systems);
  const tgtName = systemName(input.project.targetSystemId, input.systems);

  const lines: string[] = [];
  const w = (line: string) => lines.push(line);
  const indent = (n: number, line: string) => lines.push('  '.repeat(n) + line);
  const yamlStr = (s: unknown) =>
    s == null ? 'null' : `"${String(s).replace(/"/g, '\\"')}"`;

  w(`# AutoMapper Canonical Mapping Export (YAML)`);
  w(`# Generated: ${TS()}`);
  w(`# Project: ${input.project.name}`);
  w(`# Source: ${srcName} → Target: ${tgtName}`);
  w(`#`);
  w(`automapper:`);
  indent(1, `version: "1.0"`);
  indent(1, `exportedAt: ${yamlStr(TS())}`);
  indent(1, `project:`);
  indent(2, `id: ${yamlStr(input.project.id)}`);
  indent(2, `name: ${yamlStr(input.project.name)}`);
  indent(1, `source:`);
  indent(2, `name: ${yamlStr(srcName)}`);
  indent(2, `systemId: ${yamlStr(input.project.sourceSystemId)}`);
  indent(1, `target:`);
  indent(2, `name: ${yamlStr(tgtName)}`);
  indent(2, `systemId: ${yamlStr(input.project.targetSystemId)}`);
  indent(1, `entityMappings:`);

  for (const em of input.entityMappings) {
    const src = entities.get(em.sourceEntityId);
    const tgt = entities.get(em.targetEntityId);
    const fms = fmByEm.get(em.id) ?? [];

    indent(2, `- sourceEntity: ${yamlStr(src?.name ?? em.sourceEntityId)}`);
    indent(3, `targetEntity: ${yamlStr(tgt?.name ?? em.targetEntityId)}`);
    indent(3, `confidence: ${em.confidence.toFixed(3)}`);
    indent(3, `rationale: ${yamlStr(em.rationale)}`);
    if (fms.length > 0) {
      indent(3, `fieldMappings:`);
      for (const fm of fms) {
        const sf = fields.get(fm.sourceFieldId);
        const tf = fields.get(fm.targetFieldId);
        indent(4, `- source: ${yamlStr(sf?.name ?? fm.sourceFieldId)}`);
        indent(5, `target: ${yamlStr(tf?.name ?? fm.targetFieldId)}`);
        indent(5, `dataType: ${yamlStr(sf?.dataType)}`);
        indent(5, `transform: ${yamlStr(fm.transform.type)}`);
        indent(5, `confidence: ${fm.confidence.toFixed(3)}`);
        indent(5, `status: ${yamlStr(fm.status)}`);
        if (fm.rationale) indent(5, `rationale: ${yamlStr(fm.rationale)}`);
      }
    }
  }

  return lines.join('\n') + '\n';
}

// ─── 3. CSV ───────────────────────────────────────────────────────────────────

/**
 * Flat CSV export — one row per field mapping.
 * For business stakeholders who want to review mappings in Excel/Google Sheets.
 * Includes compliance notes and rationale in readable columns.
 */
export function buildCsvExport(input: BuildInput): string {
  const entities = entityById(input);
  const fields = fieldById(input);
  const emById = entityMappingById(input);

  const rows = input.fieldMappings.map((fm) => {
    const em = emById.get(fm.entityMappingId);
    const srcEntity = em ? (entities.get(em.sourceEntityId)?.name ?? '') : '';
    const tgtEntity = em ? (entities.get(em.targetEntityId)?.name ?? '') : '';
    const sf = fields.get(fm.sourceFieldId);
    const tf = fields.get(fm.targetFieldId);
    return [
      input.project.name,
      srcEntity,
      sf?.name ?? fm.sourceFieldId,
      sf?.dataType ?? '',
      sf?.required ? 'required' : '',
      tgtEntity,
      tf?.name ?? fm.targetFieldId,
      tf?.dataType ?? '',
      fm.transform.type,
      JSON.stringify(fm.transform.config),
      fm.confidence.toFixed(3),
      fm.status,
      fm.rationale.replace(/[\r\n]+/g, ' '),
    ].map(csvEscape);
  });

  const header = [
    'project',
    'sourceEntity',
    'sourceField',
    'sourceDataType',
    'sourceRequired',
    'targetEntity',
    'targetField',
    'targetDataType',
    'transformType',
    'transformConfig',
    'confidence',
    'status',
    'rationale',
  ];

  return [header, ...rows].map((r) => r.join(',')).join('\n');
}

function csvEscape(value: string): string {
  if (/[",\n]/.test(value)) return `"${value.replace(/"/g, '""')}"`;
  return value;
}

// ─── 4. MuleSoft DataWeave ────────────────────────────────────────────────────

/**
 * MuleSoft Anypoint Platform — DataWeave 2.0 transformation script.
 *
 * Generates one .dwl file per entity mapping. Each file is a valid DataWeave
 * script that can be copy-pasted into a Transform Message component in Anypoint Studio.
 *
 * Transform mapping → DataWeave:
 *   direct      → field: payload.sourceField
 *   static      → field: "literal value"
 *   concat      → field: (payload.field1 default "") ++ " " ++ (payload.field2 default "")
 *   formatDate  → field: payload.date as Date {format: "yyyy-MM-dd"}
 *   trim        → field: trim(payload.sourceField)
 *   lookup      → field: lookupTable[payload.sourceField] (comment with lookup table)
 *   regex       → field: payload.sourceField replace /pattern/ with "replacement"
 *
 * Each generated field line includes:
 *   - Source → target mapping comment
 *   - Confidence score
 *   - Rationale snippet
 */
export function buildDataWeaveExport(input: BuildInput): string {
  const entities = entityById(input);
  const fields = fieldById(input);
  const fmByEm = groupFieldMappings(input);

  const srcName = systemName(input.project.sourceSystemId, input.systems);
  const tgtName = systemName(input.project.targetSystemId, input.systems);

  const lines: string[] = [];
  const w = (line: string) => lines.push(line);

  w(`%dw 2.0`);
  w(BANNER);
  w(`//`);
  w(`// Project : ${input.project.name}`);
  w(`// Source  : ${srcName}`);
  w(`// Target  : ${tgtName}`);
  w(`// Exported: ${TS()}`);
  w(`//`);
  w(`// USAGE: Paste each section into a Transform Message component in Anypoint Studio.`);
  w(`// Each entity mapping block is independent — wire to the appropriate flow.`);
  w(`//`);
  w(`// ⚠  REVIEW BEFORE PRODUCTION:`);
  w(`//   - 'lookup' transforms require a lookup table defined in your DataWeave module`);
  w(`//   - 'concat' transforms may need null-safe coercion (payload.field? default "")`);
  w(`//   - Confidence < 0.7 mappings are marked LOW — validate business intent`);
  w(`//`);
  w(`output application/json`);
  w(`---`);
  w(``);

  for (const em of input.entityMappings) {
    const src = entities.get(em.sourceEntityId);
    const tgt = entities.get(em.targetEntityId);
    const fms = (fmByEm.get(em.id) ?? []).filter((fm) => fm.status !== 'rejected');

    w(`// ${'─'.repeat(72)}`);
    w(`// Entity: ${src?.name ?? '?'} → ${tgt?.name ?? '?'}  [confidence: ${(em.confidence * 100).toFixed(0)}%]`);
    if (em.rationale) w(`// Rationale: ${em.rationale.slice(0, 100)}${em.rationale.length > 100 ? '…' : ''}`);
    w(`//`);
    w(`// ${src?.name ?? 'Source'}_to_${tgt?.name ?? 'Target'}: (`);
    w(`{`);

    for (const fm of fms) {
      const sf = fields.get(fm.sourceFieldId);
      const tf = fields.get(fm.targetFieldId);
      const srcFieldName = sf?.name ?? fm.sourceFieldId;
      const tgtFieldName = tf?.name ?? fm.targetFieldId;
      const conf = fm.confidence;
      const confLabel = conf >= 0.8 ? '✓' : conf >= 0.6 ? '~' : '⚠ LOW';
      const shortRationale = fm.rationale
        ? fm.rationale.slice(0, 80) + (fm.rationale.length > 80 ? '…' : '')
        : '';

      w(``);
      w(`  // ${srcFieldName} → ${tgtFieldName}  [${confLabel} ${(conf * 100).toFixed(0)}%]`);
      if (shortRationale) w(`  // ${shortRationale}`);

      const dwExpr = buildDataWeaveExpression(fm, srcFieldName, sf?.dataType, tf?.dataType);
      w(`  ${tgtFieldName}: ${dwExpr},`);
    }

    w(``);
    w(`}`);
    w(``);
  }

  return lines.join('\n') + '\n';
}

function buildDataWeaveExpression(
  fm: FieldMapping,
  srcFieldName: string,
  srcType?: string,
  tgtType?: string,
): string {
  const config = fm.transform.config ?? {};
  switch (fm.transform.type) {
    case 'direct': {
      // Type coercions
      if (srcType === 'date' && tgtType === 'string')
        return `payload.${srcFieldName} as String {format: "yyyy-MM-dd"}`;
      if (srcType === 'datetime' && tgtType === 'string')
        return `payload.${srcFieldName} as String {format: "yyyy-MM-dd'T'HH:mm:ss"}`;
      if (srcType === 'string' && tgtType === 'date')
        return `payload.${srcFieldName} as Date {format: "yyyy-MM-dd"}`;
      if ((srcType === 'decimal' || srcType === 'number') && tgtType === 'string')
        return `payload.${srcFieldName} as String`;
      return `payload.${srcFieldName}`;
    }
    case 'static': {
      const val = String(config.value ?? '');
      return `"${val.replace(/"/g, '\\"')}"`;
    }
    case 'concat': {
      const flds = Array.isArray(config.fields) ? (config.fields as string[]) : [srcFieldName];
      const sep = config.separator != null ? String(config.separator) : ' ';
      const parts = flds.map((f) => `(payload.${f} default "")`);
      return parts.join(` ++ "${sep}" ++ `);
    }
    case 'trim':
      return `trim(payload.${srcFieldName})`;
    case 'formatDate': {
      const fmt = String(config.format ?? 'yyyy-MM-dd');
      return `payload.${srcFieldName} as Date {format: "${fmt}"}`;
    }
    case 'lookup': {
      const tbl = String(config.lookupTable ?? 'lookupTable');
      return `${tbl}[payload.${srcFieldName}]  // TODO: define ${tbl} as DataWeave variable`;
    }
    case 'regex': {
      const pattern = String(config.pattern ?? '.*');
      const replacement = String(config.replacement ?? '');
      return `payload.${srcFieldName} replace /${pattern}/ with "${replacement}"`;
    }
    case 'split': {
      const delimiter = String(config.delimiter ?? ',');
      const idx = Number(config.index ?? 0);
      return `(payload.${srcFieldName} splitBy "${delimiter}")[${idx}]`;
    }
    default:
      return `payload.${srcFieldName}  // transform: ${fm.transform.type}`;
  }
}

// ─── 5. Dell Boomi ────────────────────────────────────────────────────────────

/**
 * Dell Boomi — Data Map XML component descriptor.
 *
 * Generates a Boomi-compatible XML that describes the mapping between
 * source and target profiles. This XML can be imported into Boomi's
 * Map component as a starting point and then refined in the UI.
 *
 * Each entity mapping becomes a separate <Map> element.
 *
 * Boomi transform type mapping:
 *   direct      → Set Value (passthrough)
 *   static      → Set Value with literal
 *   concat      → Concatenate String
 *   trim        → Trim
 *   formatDate  → Date/Time — Reformat
 *   lookup      → Cross Reference Table lookup
 *   regex       → Comment (Boomi regex requires custom scripting step)
 */
export function buildBoomiExport(input: BuildInput): string {
  const entities = entityById(input);
  const fields = fieldById(input);
  const fmByEm = groupFieldMappings(input);

  const srcName = systemName(input.project.sourceSystemId, input.systems);
  const tgtName = systemName(input.project.targetSystemId, input.systems);

  const lines: string[] = [];
  const w = (line: string) => lines.push(line);

  w(`<?xml version="1.0" encoding="UTF-8"?>`);
  w(`<!--`);
  w(`  AutoMapper Generated Data Map — Dell Boomi`);
  w(`  Project : ${xmlEsc(input.project.name)}`);
  w(`  Source  : ${xmlEsc(srcName)}`);
  w(`  Target  : ${xmlEsc(tgtName)}`);
  w(`  Exported: ${TS()}`);
  w(`  `);
  w(`  USAGE:`);
  w(`  1. In Boomi Atomsphere, create a new Map component`);
  w(`  2. Import source and target profiles (JSON/XML) matching your connector`);
  w(`  3. Use this file as a reference to recreate field mappings`);
  w(`  4. 'CrossReference' transforms need a Cross Reference Table component`);
  w(`  5. Low-confidence fields (< 70%) are flagged — verify business intent`);
  w(`-->`);
  w(`<AutoMapperBoomiSpec version="1.0" project="${xmlEsc(input.project.name)}">`);
  w(`  <Systems>`);
  w(`    <Source name="${xmlEsc(srcName)}" />`);
  w(`    <Target name="${xmlEsc(tgtName)}" />`);
  w(`  </Systems>`);
  w(`  <Maps>`);

  for (const em of input.entityMappings) {
    const src = entities.get(em.sourceEntityId);
    const tgt = entities.get(em.targetEntityId);
    const fms = (fmByEm.get(em.id) ?? []).filter((fm) => fm.status !== 'rejected');

    w(``);
    w(`    <Map`);
    w(`      sourceProfile="${xmlEsc(src?.name ?? em.sourceEntityId)}"`);
    w(`      targetProfile="${xmlEsc(tgt?.name ?? em.targetEntityId)}"`);
    w(`      confidence="${em.confidence.toFixed(3)}"`);
    w(`      rationale="${xmlEsc(em.rationale.slice(0, 200))}">`);
    w(`      <FieldMappings>`);

    for (const fm of fms) {
      const sf = fields.get(fm.sourceFieldId);
      const tf = fields.get(fm.targetFieldId);
      const srcFieldName = sf?.name ?? fm.sourceFieldId;
      const tgtFieldName = tf?.name ?? fm.targetFieldId;
      const boomiTransform = toBoomiTransform(fm);
      const confStr = (fm.confidence * 100).toFixed(0);
      const lowConf = fm.confidence < 0.7 ? ' lowConfidence="true"' : '';

      w(`        <FieldMapping`);
      w(`          source="${xmlEsc(srcFieldName)}"`);
      w(`          target="${xmlEsc(tgtFieldName)}"`);
      w(`          sourceType="${xmlEsc(sf?.dataType ?? 'string')}"`);
      w(`          targetType="${xmlEsc(tf?.dataType ?? 'string')}"`);
      w(`          confidence="${confStr}%"`);
      w(`          status="${xmlEsc(fm.status)}"${lowConf}>`);
      w(`          <Transform type="${boomiTransform.type}">`);
      if (boomiTransform.params.length > 0) {
        for (const [k, v] of boomiTransform.params) {
          w(`            <Param name="${xmlEsc(k)}" value="${xmlEsc(v)}" />`);
        }
      }
      w(`          </Transform>`);
      if (fm.rationale) {
        w(`          <Rationale>${xmlEsc(fm.rationale.slice(0, 300))}</Rationale>`);
      }
      w(`        </FieldMapping>`);
    }

    w(`      </FieldMappings>`);
    w(`    </Map>`);
  }

  w(`  </Maps>`);
  w(`</AutoMapperBoomiSpec>`);

  return lines.join('\n') + '\n';
}

function toBoomiTransform(fm: FieldMapping): { type: string; params: [string, string][] } {
  const config = fm.transform.config ?? {};
  switch (fm.transform.type) {
    case 'direct': return { type: 'SetValue', params: [] };
    case 'static': return { type: 'SetValue', params: [['literal', String(config.value ?? '')]] };
    case 'concat': {
      const flds = Array.isArray(config.fields) ? (config.fields as string[]).join(',') : '';
      const sep = String(config.separator ?? ' ');
      return { type: 'Concatenate', params: [['fields', flds], ['separator', sep]] };
    }
    case 'trim': return { type: 'Trim', params: [] };
    case 'formatDate': return {
      type: 'DateTimeReformat',
      params: [['inputFormat', 'auto'], ['outputFormat', String(config.format ?? 'yyyy-MM-dd')]],
    };
    case 'lookup': return {
      type: 'CrossReference',
      params: [['tableName', String(config.lookupTable ?? 'CrossRefTable')]],
    };
    case 'regex': return {
      type: 'CustomScript',
      params: [
        ['note', 'Use Boomi Groovy script step — regex transforms require scripting'],
        ['pattern', String(config.pattern ?? '')],
        ['replacement', String(config.replacement ?? '')],
      ],
    };
    default: return { type: 'SetValue', params: [['note', `transform: ${fm.transform.type}`]] };
  }
}

function xmlEsc(s: string): string {
  return s
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

// ─── 6. Workato ────────────────────────────────────────────────────────────────

/**
 * Workato — Recipe JSON skeleton.
 *
 * Generates a Workato-compatible recipe JSON that describes the field mapping
 * logic. This can be imported into Workato as a recipe template.
 *
 * Workato recipes use a "datapill" pattern where each target field maps to
 * a source datapill expression. This export generates the mapping configuration
 * as Workato input field mappings that can be applied to a Workato action step.
 *
 * Structure:
 *   - One recipe per project
 *   - One step per entity mapping (create/update action in target system)
 *   - Each step's input_fields contains source → target datapill mappings
 */
export function buildWorkatoExport(input: BuildInput): object {
  const entities = entityById(input);
  const fields = fieldById(input);
  const fmByEm = groupFieldMappings(input);

  const srcName = systemName(input.project.sourceSystemId, input.systems);
  const tgtName = systemName(input.project.targetSystemId, input.systems);
  const srcType = systemType(input.project.sourceSystemId, input.systems);
  const tgtType = systemType(input.project.targetSystemId, input.systems);

  const steps = input.entityMappings.map((em, idx) => {
    const src = entities.get(em.sourceEntityId);
    const tgt = entities.get(em.targetEntityId);
    const fms = (fmByEm.get(em.id) ?? []).filter((fm) => fm.status !== 'rejected');

    const inputFields: Record<string, unknown> = {};
    for (const fm of fms) {
      const sf = fields.get(fm.sourceFieldId);
      const tf = fields.get(fm.targetFieldId);
      const srcFieldName = sf?.name ?? fm.sourceFieldId;
      const tgtFieldName = tf?.name ?? fm.targetFieldId;
      inputFields[tgtFieldName] = buildWorkatoExpression(fm, srcFieldName);
    }

    return {
      number: idx + 1,
      provider: tgtType,
      name: `${tgtType}.upsert_${(tgt?.name ?? 'record').toLowerCase()}`,
      title: `Map ${src?.name ?? 'source'} → ${tgt?.name ?? 'target'} [${(em.confidence * 100).toFixed(0)}% confidence]`,
      description: em.rationale || `Maps ${src?.name} fields to ${tgt?.name}`,
      input: inputFields,
      metadata: {
        sourceEntity: src?.name ?? em.sourceEntityId,
        targetEntity: tgt?.name ?? em.targetEntityId,
        confidence: em.confidence,
        totalFieldMappings: fms.length,
        lowConfidenceFields: fms.filter((fm) => fm.confidence < 0.7).map((fm) => {
          const sf = fields.get(fm.sourceFieldId);
          const tf = fields.get(fm.targetFieldId);
          return {
            source: sf?.name ?? fm.sourceFieldId,
            target: tf?.name ?? fm.targetFieldId,
            confidence: fm.confidence,
            rationale: fm.rationale,
          };
        }),
      },
    };
  });

  return {
    title: `${input.project.name} [AutoMapper]`,
    description: `Generated by AutoMapper. Source: ${srcName} (${srcType}) → Target: ${tgtName} (${tgtType}).`,
    version: 1,
    trigger: {
      provider: srcType,
      name: `${srcType}.new_or_updated_record`,
      title: `New or updated record in ${srcName}`,
      input: {},
    },
    steps,
    metadata: {
      generatedBy: 'AutoMapper',
      generatedAt: TS(),
      projectId: input.project.id,
      totalSteps: steps.length,
      reviewRequired: input.fieldMappings
        .filter((fm) => fm.confidence < 0.7 && fm.status !== 'rejected')
        .length,
    },
  };
}

function buildWorkatoExpression(fm: FieldMapping, srcFieldName: string): unknown {
  const config = fm.transform.config ?? {};
  switch (fm.transform.type) {
    case 'direct':
      return `{{${srcFieldName}}}`;
    case 'static':
      return config.value ?? '';
    case 'concat': {
      const flds = Array.isArray(config.fields) ? config.fields as string[] : [srcFieldName];
      const sep = String(config.separator ?? ' ');
      return flds.map((f) => `{{${f}}}`).join(sep);
    }
    case 'trim':
      return `{{${srcFieldName} | strip}}`;
    case 'formatDate':
      return `{{${srcFieldName} | date: "${config.format ?? 'YYYY-MM-DD'}"}}`;
    case 'lookup':
      return {
        type: 'lookup',
        source: `{{${srcFieldName}}}`,
        table: config.lookupTable ?? 'lookup_table',
        note: 'Configure lookup table in Workato recipe',
      };
    case 'regex':
      return {
        type: 'regex_replace',
        source: `{{${srcFieldName}}}`,
        pattern: config.pattern ?? '',
        replacement: config.replacement ?? '',
      };
    default:
      return `{{${srcFieldName}}}`;
  }
}

// ─── Format dispatcher ────────────────────────────────────────────────────────

export type ExportFormat = 'json' | 'yaml' | 'csv' | 'dataweave' | 'boomi' | 'workato';

export const EXPORT_FORMATS: Record<ExportFormat, { label: string; mime: string; ext: string; description: string }> = {
  json: {
    label: 'Canonical JSON',
    mime: 'application/json',
    ext: 'json',
    description: 'Platform-neutral mapping spec — use as input to any iPaaS or custom connector',
  },
  yaml: {
    label: 'Canonical YAML',
    mime: 'application/yaml',
    ext: 'yaml',
    description: 'Same as JSON but YAML — ideal for source control diff reviews',
  },
  csv: {
    label: 'CSV Spreadsheet',
    mime: 'text/csv',
    ext: 'csv',
    description: 'Flat field mapping table — for business stakeholder review in Excel/Sheets',
  },
  dataweave: {
    label: 'MuleSoft DataWeave',
    mime: 'text/plain',
    ext: 'dwl',
    description: 'DataWeave 2.0 transformation script for Anypoint Studio Transform Message component',
  },
  boomi: {
    label: 'Dell Boomi Map',
    mime: 'application/xml',
    ext: 'xml',
    description: 'Boomi Data Map XML descriptor — import as reference in Boomi Atomsphere Map component',
  },
  workato: {
    label: 'Workato Recipe',
    mime: 'application/json',
    ext: 'json',
    description: 'Workato recipe JSON skeleton with datapill field mappings pre-populated',
  },
};

export function buildExport(format: ExportFormat, input: BuildInput): { content: string | object; mime: string; filename: string } {
  const meta = EXPORT_FORMATS[format];
  const safeName = input.project.name.replace(/[^a-z0-9_-]/gi, '_').toLowerCase();
  const filename = `automapper_${safeName}_${format}.${meta.ext}`;

  switch (format) {
    case 'json':
      return { content: buildJsonExport(input), mime: meta.mime, filename };
    case 'yaml':
      return { content: buildYamlExport(input), mime: meta.mime, filename };
    case 'csv':
      return { content: buildCsvExport(input), mime: meta.mime, filename };
    case 'dataweave':
      return { content: buildDataWeaveExport(input), mime: meta.mime, filename };
    case 'boomi':
      return { content: buildBoomiExport(input), mime: meta.mime, filename };
    case 'workato':
      return { content: JSON.stringify(buildWorkatoExport(input), null, 2), mime: meta.mime, filename };
  }
}
